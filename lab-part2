********************************************************************
     Lab6 Manage Deployments
********************************************************************
-Create deployment using CLI
Using run option (deprecated!!)
$ kubectl run kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1 --port=808
kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.
deployment.apps/kubernetes-bootcamp created

Using create Option
$ kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1
deployment.apps/kubernetes-bootcamp created
$ kubectl get deployments
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
kubernetes-bootcamp   1/1     1            1           4m7s
$ kubectl get pods
NAME                                   READY   STATUS    RESTARTS   AGE
kubernetes-bootcamp-69fbc6f4cf-gt2jm   1/1     Running   0          5m7s
$

We should have 1 Pod. If not, run the command again. This shows:

-->NAME lists the names of the Deployments in the cluster.
-->READY shows the ratio of CURRENT/DESIRED replicas
-->UP-TO-DATE displays the number of replicas that have been updated to achieve the desired state.
-->AVAILABLE displays how many replicas of the application are available to your users.
-->AGE displays the amount of time that the application has been running.

$ kubectl describe deployments kubernetes-bootcamp
Name:                   kubernetes-bootcamp
Namespace:              default
CreationTimestamp:      Sun, 07 Jun 2020 12:24:13 +0000
Labels:                 app=kubernetes-bootcamp
Annotations:            deployment.kubernetes.io/revision: 1
Selector:               app=kubernetes-bootcamp
Replicas:               1 desired | 1 updated | 1 total | 1 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=kubernetes-bootcamp
  Containers:
   kubernetes-bootcamp:
    Image:        gcr.io/google-samples/kubernetes-bootcamp:v1
    Port:         <none>
    Host Port:    <none>
    Environment:  <none>
    Mounts:       <none>
  Volumes:        <none>
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  <none>
NewReplicaSet:   kubernetes-bootcamp-69fbc6f4cf (1/1 replicas created)
Events:
  Type    Reason             Age   From                   Message
  ----    ------             ----  ----                   -------
  Normal  ScalingReplicaSet  34s   deployment-controller  Scaled up replica set kubernetes-bootcamp-69fbc6f4cf to 1
$
$ kubectl get rs
NAME                             DESIRED   CURRENT   READY   AGE
kubernetes-bootcamp-69fbc6f4cf   1         1         1       2m19s
$
-Create  deployment using YAML
$ cat deployment.yaml
apiVersion: apps/v1 # for versions before 1.9.0 use apps/v1beta2
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2 # tells deployment to run 2 pods matching the template
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports: 
        - containerPort: 80

$ kubectl apply -f deployment.yaml
$ kubectl describe deployment nginx-deployment
$ kubectl get pods -l app=nginx

-Update the Deployment (change nginx version to 1.8)
$ cat deployment.yaml
apiVersion: apps/v1 # for versions before 1.9.0 use apps/v1beta2
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.8 # Update the version of nginx from 1.7.9 to 1.8
        ports:
        - containerPort: 80

$ kubectl apply -f deployment.yaml
$ kubectl get pods -l app=nginx
$ kubectl describe deployment nginx-deployment

-Generate Deployment Description
$ kubectl create deployment my-nginx --image nginx -o yaml --dry-run
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: my-nginx
  name: my-nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-nginx
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: my-nginx
    spec:
      containers:
      - image: nginx
        name: nginx
        resources: {}
status: {}

********************************************************************
     Lab7 Manage Services
********************************************************************

For some parts of your application (e.g. frontends) you may want to expose a 
Service onto an external (outside of your cluster) IP address.

Kubernetes ServiceTypes allow you to specify what kind of service you want. The default is ClusterIP.

Type values and their behaviors are:

-ClusterIP: Exposes the service on a cluster-internal IP. Choosing this value makes the service only reachable from within the cluster. This is the default ServiceType.
-NodePort: Exposes the service on each Node’s IP at a static port (the NodePort). A ClusterIP service, to which the NodePort service will route, is automatically created. You’ll be able to contact the NodePort service, from outside the cluster, by requesting <NodeIP>:<NodePort>.
-LoadBalancer: Exposes the service externally using a cloud provider’s load balancer. NodePort and ClusterIP services, to which the external load balancer will route, are automatically created.
-ExternalName: Maps the service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. This requires version 1.7 or higher of kube-dns


1-Create Services and expose deployment
vagrant@master:~$ kubectl delete deployments --all
vagrant@master:~$ kubectl run kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1 --port=8080
vagrant@master:~$ kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1


vagrant@master:~$ kubectl get deployments
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
kubernetes-bootcamp   1/1     1            1           11s
$
vagrant@master:~$ $ kubectl get services
NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   10.96.0.1    <none>        443/TCP   11m
$
vagrant@master:~$ kubectl get services
NAME                  TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
kubernetes            ClusterIP   10.96.0.1       <none>        443/TCP          12m
kubernetes-bootcamp   NodePort    10.102.86.175   <none>        8080:30652/TCP   23s
$

vagrant@master:~$ kubectl get services
NAME                  TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE
kubernetes            ClusterIP   10.96.0.1      <none>        443/TCP          2d
kubernetes-bootcamp   NodePort    10.106.4.223   <none>        8080:32156/TCP   7s
vagrant@master:~$ kubectl describe services/kubernetes-bootcamp
Name:                     kubernetes-bootcamp
Namespace:                default
Labels:                   run=kubernetes-bootcamp
Annotations:              <none>
Selector:                 run=kubernetes-bootcamp
Type:                     NodePort
IP:                       10.102.86.175
Port:                     <unset>  8080/TCP
TargetPort:               8080/TCP
NodePort:                 <unset>  30652/TCP
Endpoints:                172.18.0.4:8080
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   <none>
$                   <none>

vagrant@master:~$ export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}')
vagrant@master:~$ echo NODE_PORT=$NODE_PORT
NODE_PORT=30652
$
vagrant@master:~$ ifconfig 
My IP is 10.0.0.10
vagrant@master:~$ curl 10.0.0.10:$NODE_PORT
Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-69bf88c8c-5x9x9 | v=1
vagrant@master:~
Try to access with portfording on virtualbox (Nat Adapter)
http://localhost:8081   (8081<-->31042)
http://192.168.135.89:8081/

2-Create Service using YAML template
2.1 Create the deployment
$ cat app-my-nginx.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-nginx
spec:
  selector:
    matchLabels:
      app: my-nginx
  replicas: 2
  template:
    metadata:
      labels:
        app: my-nginx
    spec:
      containers:
      - name: my-nginx
        image: nginx
        ports:
        - containerPort: 80
$ kubectl apply -f ./app-my-nginx.yaml
$ kubectl get pods -l app=my-nginx -o wide
$ kubectl get pods -l app=my-nginx -o yaml | grep podIP

2.2 Create the service (Type NodePort)

$ cat nginx-svc.yaml 
apiVersion: v1
kind: Service
metadata:
  name: my-nginx
  labels:
    app: my-nginx
spec:
  ports:
  - port: 8081
    protocol: TCP
    targetPort: 80
  type: NodePort
  selector:
    app: my-nginx

$ kubectl apply -f nginx-svc.yaml 
$ kubectl get svc my-nginx
NAME       TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
my-nginx   NodePort   10.101.148.220   <none>        8081:32040/TCP   8m54s
$ kubectl describe svc my-nginx

2.3 Access to Service

$  curl http://10.101.148.220:32040

$ vagrant ssh node1
vagrant@node1:~$  curl http://10.101.148.220:8081
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
vagrant@node1:~$

2.4 Create a second Service (Type LoadBalancer)
$ cat app2-my-nginx.yaml
---
apiVersion: v1
kind: Service
metadata:
  name: my-nginx-2
  labels:
    app: my-nginx-2
spec:
  ports:
  - port: 8081
    protocol: TCP
    targetPort: 80
  type: LoadBalancer
  selector:
    app: my-nginx-2
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-nginx-2
spec:
  selector:
    matchLabels:
      app: my-nginx-2
  replicas: 2
  template:
    metadata:
      labels:
        app: my-nginx-2
    spec:
      containers:
      - name: my-nginx-2
        image: nginx
        ports:
        - containerPort: 80 

$ kubectl apply -f app2-my-nginx.yaml
service/my-nginx-2 created
deployment.apps/my-nginx-2 created
$ kubectl get services
NAME         TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
kubernetes   ClusterIP      10.96.0.1        <none>        443/TCP          26h
my-nginx     NodePort       10.101.148.220   <none>        8081:32040/TCP   42m
my-nginx-2   LoadBalancer   10.110.0.223     <pending>     8081:32477/TCP   22m
$ curl http://10.0.0.10:32477

https://kubernetes.io/docs/concepts/services-networking/ingress/
https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer

********************************************************************
     Lab8 Scale up Application
********************************************************************

1-Scaling an application
vagrant@master:~$ kubectl delete deployments --all

vagrant@master:~$ kubectl run kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1 --port=8080
vagrant@master:~$ kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1

vagrant@master:~$ kubectl get deployments
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
kubernetes-bootcamp   1/1     1            1           8m24s
$
vagrant@master:~$ kubectl get rs
NAME                             DESIRED   CURRENT   READY   AGE
kubernetes-bootcamp-765bf4c7b4   1         1         1       10m
vagrant@master:~$
Two important columns of this command are:

-->DESIRED displays the desired number of replicas of the application, 
which you define when you create the Deployment. This is the desired state.
-->CURRENT displays how many replicas are currently running.

vagrant@master:~$ kubectl scale deployments/kubernetes-bootcamp --replicas=4
deployment.apps/kubernetes-bootcamp scaled
vagrant@master:~$ kubectl get deployments
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
kubernetes-bootcamp   4/4     4            4           13m
vagrant@master:~$ kubectl get pods -o wide
NAME                                   READY   STATUS    RESTARTS   AGE   IP           NODE      NOMINATED NODE   READINESS GATES
kubernetes-bootcamp-765bf4c7b4-6stxk   1/1     Running   0          12s   172.18.0.7   minikube   <none>           <none>
kubernetes-bootcamp-765bf4c7b4-j6p7f   1/1     Running   0          13m   172.18.0.3   minikube   <none>           <none>
kubernetes-bootcamp-765bf4c7b4-k4z7r   1/1     Running   0          12s   172.18.0.8   minikube   <none>           <none>
kubernetes-bootcamp-765bf4c7b4-zdjd4   1/1     Running   0          12s   172.18.0.9   minikube   <none>           <none>
vagrant@master:~$ kubectl get rs
NAME                             DESIRED   CURRENT   READY   AGE
kubernetes-bootcamp-765bf4c7b4   4         4         4       13m
$

vagrant@master:~$ kubectl get svc
NAME                  TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
kubernetes            ClusterIP   10.96.0.1        <none>        443/TCP          17m
kubernetes-bootcamp   NodePort    10.108.164.126   <none>        8080:32210/TCP   17m
$

vagrant@master:~$ kubectl describe services/kubernetes-bootcamp
Name:                     kubernetes-bootcamp
Namespace:                default
Labels:                   run=kubernetes-bootcamp
Annotations:              <none>
Selector:                 run=kubernetes-bootcamp
Type:                     NodePort
IP:                       10.108.164.126
Port:                     <unset>  8080/TCP
TargetPort:               8080/TCP
NodePort:                 <unset>  32210/TCP
Endpoints:                172.18.0.3:8080,172.18.0.7:8080,172.18.0.8:8080 + 1 more...
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   <none>
$ kubectl get srv
error: the server doesn't have a resource type "srv"



vagrant@master:~$ kubectl expose deployment/kubernetes-bootcamp --type="NodePort" --port 8080

vagrant@master:~$ kubectl describe services/kubernetes-bootcamp
Name:                     kubernetes-bootcamp
Namespace:                default
Labels:                   run=kubernetes-bootcamp
Annotations:              <none>
Selector:                 run=kubernetes-bootcamp
Type:                     NodePort
IP:                       10.106.4.223
Port:                     <unset>  8080/TCP
TargetPort:               8080/TCP
NodePort:                 <unset>  32156/TCP
Endpoints:                10.32.0.5:8080,10.40.0.1:8080,10.40.0.2:8080
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   <none>

vagrant@master:~$ export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}')
vagrant@master:~$ export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}')
vagrant@master:~$ echo NODE_PORT=$NODE_PORT
NODE_PORT=32210
$
vagrant@master:~$ curl 10.0.0.10:$NODE_PORT
Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-765bf4c7b4-zdjd4 | v=1
$

2-Scale down
vagrant@master:~$ kubectl scale deployments/kubernetes-bootcamp --replicas=2
deployment.apps/kubernetes-bootcamp scaled
vagrant@master:~$ kubectl get deployments
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
kubernetes-bootcamp   2/2     2            2           22m
vagrant@master:~$ kubectl get pods -o wide
NAME                                   READY   STATUS        RESTARTS   AGE    IP           NODE       NOMINATED NODE   READINESS GATES
kubernetes-bootcamp-765bf4c7b4-6stxk   1/1     Terminating   0          9m6s   172.18.0.7   minikube   <none>           <none>
kubernetes-bootcamp-765bf4c7b4-j6p7f   1/1     Running       0          22m    172.18.0.3   minikube   <none>           <none>
kubernetes-bootcamp-765bf4c7b4-k4z7r   1/1     Running       0          9m6s   172.18.0.8   minikube   <none>           <none>
kubernetes-bootcamp-765bf4c7b4-zdjd4   1/1     Terminating   0          9m6s   172.18.0.9   minikube   <none>           <none>
vagrant@master:~$ kubectl get pods -o wide
NAME                                   READY   STATUS        RESTARTS   AGE     IPNODE       NOMINATED NODE   READINESS GATES
kubernetes-bootcamp-765bf4c7b4-6stxk   1/1     Terminating   0          9m13s   172.18.0.7minikube   <none>           <none>
kubernetes-bootcamp-765bf4c7b4-j6p7f   1/1     Running       0          22m     172.18.0.3minikube   <none>           <none>
kubernetes-bootcamp-765bf4c7b4-k4z7r   1/1     Running       0          9m13s   172.18.0.8minikube   <none>           <none>
kubernetes-bootcamp-765bf4c7b4-zdjd4   1/1     Terminating   0          9m13s   172.18.0.9minikube   <none>           <none>
vagrant@master:~$ kubectl get pods -o wide
NAME                                   READY   STATUS    RESTARTS   AGE     IP           NODE       NOMINATED NODE   READINESS GATES
kubernetes-bootcamp-765bf4c7b4-j6p7f   1/1     Running   0          22m     172.18.0.3   minikube   <none>           <none>
kubernetes-bootcamp-765bf4c7b4-k4z7r   1/1     Running   0          9m33s   172.18.0.8   minikube   <none>           <none>
$

3-Delete Pods
vagrant@master:~$ kubectl delete pods kubernetes-bootcamp-765bf4c7b4-2xkmz
pod "kubernetes-bootcamp-69bf88c8c-5x9x9" deleted
-->Aussitôt supprimé, aussitôt recréé ! 

vagrant@master:~$ kubectl delete pods kubernetes-bootcamp-765bf4c7b4-2xkmz
pod "kubernetes-bootcamp-765bf4c7b4-2xkmz" deleted
vagrant@master:~$ kubectl get pods -o wide
NAME                                   READY   STATUS        RESTARTS   AGE    IP NODE       NOMINATED NODE   READINESS GATES
kubernetes-bootcamp-765bf4c7b4-2xkmz   1/1     Terminating   0          59s    172.18.0.7 minikube   <none>           <none>
kubernetes-bootcamp-765bf4c7b4-5vrq6   1/1     Running       0          59s    172.18.0.8 minikube   <none>           <none>

vagrant@master:~$ kubectl get pods -o wide
NAME                                   READY   STATUS    RESTARTS   AGE    IP            NODE       NOMINATED NODE   READINESS GATES
kubernetes-bootcamp-765bf4c7b4-5vrq6   1/1     Running   0          75s    172.18.0.8    minikube   <none>           <none>
kubernetes-bootcamp-765bf4c7b4-6xhx8   1/1     Running   0          75s    172.18.0.9    minikube   <none>           <none>
$

********************************************************************
     Lab9 Performing a Rolling Update
********************************************************************
Rolling updates allow the following actions:

-->Promote an application from one environment to another (via container image updates)
-->Rollback to previous versions
-->Continuous Integration and Continuous Delivery of applications with zero downtime

1-Update the version of the app (V1 to V2)

vagrant@master:~$ kubectl delete deployments --all
vagrant@master:~$ kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1
vagrant@master:~$ kubectl scale deployments/kubernetes-bootcamp --replicas=4
deployment.apps/kubernetes-bootcamp scaled
vagrant@master:~$ kubectl get pods
NAME                                   READY   STATUS    RESTARTS   AGE
kubernetes-bootcamp-765bf4c7b4-8s9tp   1/1     Running   0          19m
kubernetes-bootcamp-765bf4c7b4-qbjtk   1/1     Running   0          19m
kubernetes-bootcamp-765bf4c7b4-smr9p   1/1     Running   0          19m
kubernetes-bootcamp-765bf4c7b4-zmqf5   1/1     Running   0          19m
$

$ kubectl describe pods
Name:         kubernetes-bootcamp-765bf4c7b4-8s9tp
Namespace:    default
Priority:     0
Node:         minikube/172.17.0.41
Start Time:   Sun, 07 Jun 2020 16:01:18 +0000
Labels:       pod-template-hash=765bf4c7b4
              run=kubernetes-bootcamp
Annotations:  <none>
Status:       Running
IP:           172.18.0.3
IPs:
  IP:           172.18.0.3
Controlled By:  ReplicaSet/kubernetes-bootcamp-765bf4c7b4
Containers:
  kubernetes-bootcamp:
    Container ID:   docker://654460c84fcf2c8f29b0edde2313cd415329e80c8af8317547b4d5cca03d34f3
    Image:          gcr.io/google-samples/kubernetes-bootcamp:v1
    Image ID:       docker-pullable://jocatalin/kubernetes-bootcamp@sha256:0d6b8ee63bb57c5f5b6156f446b3bc3b3c143d233037f3a2f00e279c8fcc64af
    Port:           8080/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Sun, 07 Jun 2020 16:01:21 +0000
    Ready:          True
    Restart Count:  0
    Environment:    <none>
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-xcsrc (ro)
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:
  default-token-xcsrc:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-xcsrc
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  <none>
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type     Reason            Age                From               Message
  ----     ------            ----               ----               -------
  Warning  FailedScheduling  19m (x2 over 19m)  default-scheduler  0/1 nodes are available:1 node(s) had taints that the pod didn't tolerate.
  Normal   Scheduled         19m                default-scheduler  Successfully assigned default/kubernetes-bootcamp-765bf4c7b4-8s9tp to minikube
  Normal   Pulled            19m                kubelet, minikube  Container image "gcr.io/google-samples/kubernetes-bootcamp:v1" already present on machine
  Normal   Created           19m                kubelet, minikube  Created container kubernetes-bootcamp
  Normal   Started           19m                kubelet, minikube  Started container kubernetes-bootcamp


vagrant@master:~$ $ kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2
deployment.apps/kubernetes-bootcamp image updated
vagrant@master:~$ kubectl get pods
NAME                                   READY   STATUS        RESTARTS   AGE
kubernetes-bootcamp-765bf4c7b4-8s9tp   1/1     Terminating   0          24m
kubernetes-bootcamp-765bf4c7b4-qbjtk   1/1     Running       0          24m
kubernetes-bootcamp-765bf4c7b4-smr9p   1/1     Running       0          24m
kubernetes-bootcamp-765bf4c7b4-zmqf5   1/1     Terminating   0          24m
kubernetes-bootcamp-7d6f8694b6-4cjdr   1/1     Running       0          2s
kubernetes-bootcamp-7d6f8694b6-7gwqp   1/1     Running       0          2s
vagrant@master:~$ kubectl get pods
NAME                                   READY   STATUS        RESTARTS   AGE
kubernetes-bootcamp-765bf4c7b4-8s9tp   1/1     Terminating   0          24m
kubernetes-bootcamp-765bf4c7b4-qbjtk   1/1     Terminating   0          24m
kubernetes-bootcamp-765bf4c7b4-smr9p   1/1     Terminating   0          24m
kubernetes-bootcamp-765bf4c7b4-zmqf5   1/1     Terminating   0          24m
kubernetes-bootcamp-7d6f8694b6-2h4c8   1/1     Running       0          9s
kubernetes-bootcamp-7d6f8694b6-4cjdr   1/1     Running       0          11s
kubernetes-bootcamp-7d6f8694b6-7gwqp   1/1     Running       0          11s
kubernetes-bootcamp-7d6f8694b6-kv4cp   1/1     Running       0          9s

vagrant@master:~$ kubectl get pods
NAME                                   READY   STATUS        RESTARTS   AGE
kubernetes-bootcamp-765bf4c7b4-8s9tp   0/1     Terminating   0          24m
kubernetes-bootcamp-765bf4c7b4-qbjtk   0/1     Terminating   0          24m
kubernetes-bootcamp-765bf4c7b4-smr9p   0/1     Terminating   0          24m
kubernetes-bootcamp-7d6f8694b6-2h4c8   1/1     Running       0          41s
kubernetes-bootcamp-7d6f8694b6-4cjdr   1/1     Running       0          43s
kubernetes-bootcamp-7d6f8694b6-7gwqp   1/1     Running       0          43s
kubernetes-bootcamp-7d6f8694b6-kv4cp   1/1     Running       0          41s
vagrant@master:~$ kubectl get pods
NAME                                   READY   STATUS    RESTARTS   AGE
kubernetes-bootcamp-7d6f8694b6-2h4c8   1/1     Running   0          52s
kubernetes-bootcamp-7d6f8694b6-4cjdr   1/1     Running   0          54s
kubernetes-bootcamp-7d6f8694b6-7gwqp   1/1     Running   0          54s
kubernetes-bootcamp-7d6f8694b6-kv4cp   1/1     Running   0          52s

2-Verify an update (V1 to V2)

vagrant@master:~$ kubectl rollout status deployments/kubernetes-bootcamp
deployment "kubernetes-bootcamp" successfully rolled out
$
vagrant@master:~$ kubectl describe pods
Name:         kubernetes-bootcamp-7d6f8694b6-2h4c8
Namespace:    default
Priority:     0
Node:         minikube/172.17.0.41
Start Time:   Sun, 07 Jun 2020 16:25:14 +0000
Labels:       pod-template-hash=7d6f8694b6
              run=kubernetes-bootcamp
Annotations:  <none>
Status:       Running
IP:           172.18.0.12
IPs:
  IP:           172.18.0.12
Controlled By:  ReplicaSet/kubernetes-bootcamp-7d6f8694b6
Containers:
  kubernetes-bootcamp:
    Container ID:   docker://7e7fa05fa3be2bee1f36a155608b85f5a9386ed7b8432b0f22e25de68fe380f1
    Image:          jocatalin/kubernetes-bootcamp:v2
    Image ID:       docker-pullable://jocatalin/kubernetes-bootcamp@sha256:fb1a3ced00cecfc1f83f18ab5cd14199e30adc1b49aa4244f5d65ad3f5feb2a5

vagrant@master:~$ kubectl describe services/kubernetes-bootcamp
Name:                     kubernetes-bootcamp
Namespace:                default
Labels:                   run=kubernetes-bootcamp
Annotations:              <none>
Selector:                 run=kubernetes-bootcamp
Type:                     NodePort
IP:                       10.111.102.71
Port:                     <unset>  8080/TCP
TargetPort:               8080/TCP
NodePort:                 <unset>  30434/TCP
Endpoints:                172.18.0.10:8080,172.18.0.11:8080,172.18.0.12:8080 + 1 more...
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   <none>
$


3-Rollback an update
-Image V2 to V10
vagrant@master:~$ kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v10
deployment.apps/kubernetes-bootcamp image updated
vagrant@master:~$ kubectl get deployments
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
kubernetes-bootcamp   3/4     2            3           33m
vagrant@master:~$ kubectl get pods
NAME                                   READY   STATUS             RESTARTS   AGE
kubernetes-bootcamp-7d6f8694b6-2h4c8   1/1     Terminating        0          9m37s
kubernetes-bootcamp-7d6f8694b6-4cjdr   1/1     Running            0          9m39s
kubernetes-bootcamp-7d6f8694b6-7gwqp   1/1     Running            0          9m39s
kubernetes-bootcamp-7d6f8694b6-kv4cp   1/1     Running            0          9m37s
kubernetes-bootcamp-886577c5d-ktkdh    0/1     ImagePullBackOff   0          14s
kubernetes-bootcamp-886577c5d-pl6mb    0/1     ImagePullBackOff   0          14s
vagrant@master:~$ kubectl describe pods

vagrant@master:~$ kubectl rollout undo deployments/kubernetes-bootcamp
deployment.apps/kubernetes-bootcamp rolled back
vagrant@master:~$ kubectl get pods
NAME                                   READY   STATUS        RESTARTS   AGE
kubernetes-bootcamp-7d6f8694b6-4cjdr   1/1     Running       0          10m
kubernetes-bootcamp-7d6f8694b6-7gwqp   1/1     Running       0          10m
kubernetes-bootcamp-7d6f8694b6-945nh   1/1     Running       0          4s
kubernetes-bootcamp-7d6f8694b6-kv4cp   1/1     Running       0          10m
kubernetes-bootcamp-886577c5d-ktkdh    0/1     Terminating   0          94s

vagrant@master:~$ kubectl get pods
NAME                                   READY   STATUS    RESTARTS   AGE
kubernetes-bootcamp-7d6f8694b6-4cjdr   1/1     Running   0          11m
kubernetes-bootcamp-7d6f8694b6-7gwqp   1/1     Running   0          11m
kubernetes-bootcamp-7d6f8694b6-945nh   1/1     Running   0          17s
kubernetes-bootcamp-7d6f8694b6-kv4cp   1/1     Running   0          11m
vagrant@master:~$ kubectl describe pods


-Image V2 to V1
vagrant@master:~$ kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v1
deployment.apps/kubernetes-bootcamp image updated
vagrant@master:~$  kubectl get podsNAME                                   READY   STATUS        RESTARTS   AGE
kubernetes-bootcamp-765bf4c7b4-5jnx7   1/1     Running       0          4s
kubernetes-bootcamp-765bf4c7b4-9c6wc   1/1     Running       0          7s
kubernetes-bootcamp-765bf4c7b4-pw9fl   1/1     Running       0          7s
kubernetes-bootcamp-765bf4c7b4-srhxb   1/1     Running       0          4s
kubernetes-bootcamp-7d6f8694b6-4cjdr   1/1     Terminating   0          18m
kubernetes-bootcamp-7d6f8694b6-7gwqp   1/1     Terminating   0          18m
kubernetes-bootcamp-7d6f8694b6-876tj   0/1     Terminating   0          3m55s
kubernetes-bootcamp-7d6f8694b6-kv4cp   1/1     Terminating   0          18m
$
vagrant@master:~$  kubectl get pods
NAME                                   READY   STATUS    RESTARTS   AGE
kubernetes-bootcamp-765bf4c7b4-5jnx7   1/1     Running   0          75s
kubernetes-bootcamp-765bf4c7b4-9c6wc   1/1     Running   0          78s
kubernetes-bootcamp-765bf4c7b4-pw9fl   1/1     Running   0          78s
kubernetes-bootcamp-765bf4c7b4-srhxb   1/1     Running   0          75s
$
vagrant@master:~$ kubectl describe pods

********************************************************************
     Lab10 Working with Volumes
********************************************************************
-Two classes of k8s volumes:
-->In cluster Storage Server (ex. hostpath or local)
https://kubernetes.io/docs/concepts/storage/volumes/#local
https://kubernetes.io/docs/concepts/storage/volumes/#hostpath
-->External Storage Server using CSI Provisioner (ex.Cloud or NFS)
-Types of volumes :
https://kubernetes.io/docs/concepts/storage/volumes/

-Static and Dynamic Provisioning of volumes
-->Static by using PersistentVolume and PersistentVolumeClaim (PVC)
(exemple  GCE, AWS EBS, or using external NFS)
https://kubernetes.io/docs/concepts/storage/persistent-volumes/
-->Dynamic Provisioning by using StorageClasses and PersistentVolumeClaim (PersistentVolume is Optional)
(exemple using NFS client provisioner or Cloud client provisioner)

1-Static Provisioning with Hostpath volumes
vagrant@master:~$ cat hostpathex.yaml 
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mypv
  labels:
    type: local
spec:
  capacity:
    storage: 500Mi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/tmp/mypv"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mypvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 300Mi
---
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
    - name: myfrontend
      image: nginx
      volumeMounts:
      - mountPath: "/usr/share/nginx/html/"
        name: mypd
  volumes:
    - name: mypd
      persistentVolumeClaim:
        claimName: mypvc
vagrant@master:~$ kubectl apply -f hostpathex.yaml

-->using selector/matchLabels:
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mypvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 300Mi
  selector:
    matchLabels:
      type: "local"
---
2-Static Provisioning with NFS
https://github.com/kubernetes/examples/tree/master/staging/volumes
---->Prerequisites
SSH in to each node and install the nfs-common OS package (e.g. sudo apt-get update && sudo apt-get -y install nfs-common)
---->Create NFS server Pod

vagrant@master:~$ cat nfs-server-rc.yaml 
kind: Service
apiVersion: v1
metadata:
  name: nfs-server
spec:
  ports:
    - name: nfs
      port: 2049
    - name: mountd
      port: 20048
    - name: rpcbind
      port: 111
  selector:
    role: nfs-server
---
apiVersion: v1
kind: ReplicationController
metadata:
  name: nfs-server
spec:
  replicas: 1
  selector:
    role: nfs-server
  template:
    metadata:
      labels:
        role: nfs-server
    spec:
      containers:
      - name: nfs-server
        image: gcr.io/google_containers/volume-nfs:0.8
        ports:
          - name: nfs
            containerPort: 2049
          - name: mountd
            containerPort: 20048
          - name: rpcbind
            containerPort: 111
        securityContext:
          privileged: true
        volumeMounts:
          - mountPath: /exports
            name: nfs-export-fast
      volumes:
        - name: nfs-export-fast
          hostPath:
            path: /data/nfs

vagrant@master:~$ kubectl create -f nfs-server-rc.yaml

vagrant@master:~$ kubectl get pods -o wide
NAME               READY     STATUS    RESTARTS   AGE       IP          NODE      NOMINATED NODE
nfs-server-nqml2   1/1       Running   0          14m       10.32.0.4   node2     <none>

- SSH into "node2", where our NFS server pod is running
vagrant@master:~$ ssh node2
vagrant@node2:~$ cat /data/nfs/index.html
Hello from NFS!
vagrant@node2:~$ exit
logout
Connection to node2 closed.

---->Create Pod using our NFS server
vagrant@master:~$ kubectl get service
NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE
kubernetes   ClusterIP   10.96.0.1      <none>        443/TCP                      5d
nfs-server   ClusterIP   10.109.32.89   <none>        2049/TCP,20048/TCP,111/TCP   17m
vagrant@master:~$ 
Consuming the Mount by creating a pod

vagrant@master:~$ cat nginx-nfs.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: web
spec:
  containers:
  - name: web
    image: nginx
    volumeMounts:
      # name must match the volume name below
    - name: nfs
      mountPath: "/usr/share/nginx/html/"
    ports:
    - name: web
      containerPort: 80
      protocol: TCP
  volumes:
  - name: nfs
    nfs:
      # FIXME: use the right name
      #server: nfs-server.default.kube.local
      server: "10.109.32.89"
      path: "/"
      readOnly: false

vagrant@master:~$ kubectl create -f nginx-nfs.yaml

vagrant@master:~$ kubectl get pods -o wide
NAME               READY     STATUS    RESTARTS   AGE       IP          NODE      NOMINATED NODE
nfs-server-nqml2   1/1       Running   0          22m       10.32.0.4   node2     <none>
web                1/1       Running   0          21s       10.40.0.2   node1     <none>
vagrant@master:~$

Exec into the container to test writing to the NFS
vagrant@master:~$ kubectl exec -it web -- bash
root@web:/# cat /usr/share/nginx/html/index.html
Hello from NFS!
root@web:/# 
root@web:/# echo "create new file" >> /usr/share/nginx/html/test.txt
root@web:/# cat /usr/share/nginx/html/test.txt   
create new file
root@web:/# exit

# SSH into "node2", where our NFS server pod is running

vagrant@master:~$ ssh node2

Verify that the file created inside of our web pod (running on "storage1") was persisted to the NFS directory on "storage0":

vagrant@node2:~$ cat /data/nfs/
index.html  test.txt    
vagrant@node2:~$ cat /data/nfs/test.txt 
create new file
vagrant@node2:~$ 


3-Dynamic Provisioning using the NFS Provisioner StorageClass


###Stateful Applications: Deploying WordPress and MySQL with NFS Dynamic Volumes###

-Create the NFS Server POD

vagrant@master:~$ kubectl create -f nfs-server-rc.yaml

-Create the default storage class (replace the server IP by the CLUSTER-IP of your nfs-server service , kubectl get service)

vagrant@master:~$ cat nfs-storageclass.yaml 
kind: StorageClass
apiVersion: storage.k8s.io/v1beta1
metadata:
  namespace: default
  name: default-storage
  annotations:
    storageclass.kubernetes.io/is-default-class: "true"
  labels:
    kubernetes.io/cluster-service: "true"
provisioner: kubernetes.io/nfs
parameters:
  path: /
  server: 10.111.26.188

vagrant@master:~$ kubectl create -f nfs-storageclass.yaml 
storageclass.storage.k8s.io/default-storage created
vagrant@master:~$ kubectl get storageclass
NAME                        PROVISIONER         AGE
default-storage (default)   kubernetes.io/nfs   16s

-Create persistent volumes (should be created by Admin cluster)

vagrant@master:~$ cat nfs-persistent-volume.yaml 
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-pv-1
  labels:
    type: local
spec:
  persistentVolumeReclaimPolicy: Recycle
  storageClassName: default-storage
  capacity:
    storage: 500Mi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /data/nfs/pv-1
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-pv-2
  labels:
    type: local
spec:
  storageClassName: default-storage
  capacity:
    storage: 500Mi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /data/nfs/pv-2
vagrant@master:~$

vagrant@master:~$ kubectl create -f nfs-persistent-volume.yaml 
persistentvolume/local-pv-1 created
persistentvolume/local-pv-2 created
vagrant@master:~$ kubectl get persistentvolumes
NAME         CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM     STORAGECLASS      REASON    AGE
local-pv-1   500Mi      RWO            Retain           Available             default-storage             11s
local-pv-2   500Mi      RWO            Retain           Available             default-storage             11s
vagrant@master:~$


-Create a Secret for MySQL Password
vagrant@master:~$  kubectl create secret generic mysql-pass --from-literal=password=YOUR_PASSWORD

default-token-6dtkp   kubernetes.io/service-account-token   3         15d
mysql-pass            Opaque                                1         1d
vagrant@master:~$ 

-Create persistent volumes claim and Deploy application (Mysql and Wordpress)
vagrant@master:~$ cat wordpress-deployment.yaml 
apiVersion: v1
kind: Service
metadata:
  name: wordpress-mysql
  labels:
    app: wordpress
spec:
  ports:
    - port: 3306
  selector:
    app: wordpress
    tier: mysql
  clusterIP: None
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
  labels:
    app: wordpress
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 400Mi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress-mysql
  labels:
    app: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
        tier: mysql
    spec:
      containers:
      - image: mysql:5.6
        name: mysql
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 3306
          name: mysql
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
  labels:
    app: wordpress
spec:
  ports:
    - port: 80
  selector:
    app: wordpress
    tier: frontend
  type: LoadBalancer
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wp-pv-claim
  labels:
    app: wordpress
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 400Mi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  labels:
    app: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
        tier: frontend
    spec:
      containers:
      - image: wordpress:4.8-apache
        name: wordpress
        env:
        - name: WORDPRESS_DB_HOST
          value: wordpress-mysql
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 80
          name: wordpress
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wp-pv-claim
vagrant@master:~$ 

vagrant@master:~$ kubectl create -f wordpress-deployment.yaml  
service/wordpress-mysql created
persistentvolumeclaim/mysql-pv-claim created
deployment.apps/wordpress-mysql created
service/wordpress created
persistentvolumeclaim/wp-pv-claim created
deployment.apps/wordpress created
vagrant@master:~$ kubectl get pods -o wide
NAME                              READY     STATUS        RESTARTS   AGE       IP          NODE      NOMINATED NODE
nfs-server-kn8vn                  1/1       Running       0          2h        10.32.0.4   node2     <none>
wordpress-5bc75fd7bd-pqcqf        1/1       Running       0          4s        10.32.0.5   node2     <none>
wordpress-mysql-565494758-8vbd2   1/1       Running       0          5s        10.40.0.2   node1     <none>

-Inspect deployment

vagrant@master:~$ ssh node2
vagrant@node2:~$ ls /data/nfs/
pv-1  pv-2
vagrant@node2:~$ ls /data/nfs/pv-1
index.php    wp-activate.php     wp-comments-post.php  wp-content   wp-links-opml.php  wp-mail.php      wp-trackback.php
license.txt  wp-admin            wp-config.php         wp-cron.php  wp-load.php        wp-settings.php  xmlrpc.php
readme.html  wp-blog-header.php  wp-config-sample.php  wp-includes  wp-login.php       wp-signup.php
vagrant@node2:~$ ls /data/nfs/pv-2
auto.cnf  ibdata1  ib_logfile0  ib_logfile1  mysql  performance_schema  wordpress

vagrant@master:~$ kubectl exec wordpress-mysql-565494758-8vbd2 -it -- bash
root@wordpress-mysql-565494758-8vbd2:/# ls
bin  boot  dev	docker-entrypoint-initdb.d  entrypoint.sh  etc	home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

root@wordpress-mysql-565494758-8vbd2:/# mysql -u root -p
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 5
Server version: 5.6.41 MySQL Community Server (GPL)

Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| wordpress          |
+--------------------+
4 rows in set (0.00 sec)

-Test Wordpress
vagrant@master:~$ kubectl get services
NAME              TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)                      AGE
kubernetes        ClusterIP      10.96.0.1        <none>        443/TCP                      16d
nfs-server        ClusterIP      10.107.221.244   <none>        2049/TCP,20048/TCP,111/TCP   12h
wordpress         LoadBalancer   10.106.222.58    <pending>     80:31857/TCP                 10h
wordpress-mysql   ClusterIP      None             <none>        3306/TCP                     10h
vagrant@master:~$ 
vagrant@master:~$ kubectl describe svc wordpress | grep NodePort 
NodePort:                 <unset>  31857/TCP
vagrant@master:~$ 

Put the two together to get the URL for the WordPress service: http://10.106.222.58:31857

-Scale Deployment
vagrant@master:~$ kubectl scale --replicas=2 deployment/wordpress
deployment.extensions/wordpress scaled
vagrant@master:~$ kubectl get pods -o wide
NAME                              READY     STATUS        RESTARTS   AGE       IP          NODE      NOMINATED NODE
nfs-server-kn8vn                  1/1       Running       0          2h        10.32.0.4   node2     <none>
web                               0/1       Terminating   0          9d        10.40.0.2   node1     <none>
wordpress-5bc75fd7bd-pqcqf        1/1       Running       0          9m        10.32.0.5   node2     <none>
wordpress-5bc75fd7bd-spclk        1/1       Running       0          4s        10.40.0.3   node1     <none>
wordpress-mysql-565494758-8vbd2   1/1       Running       0          9m        10.40.0.2   node1     <none>


-clean Deployment
vagrant@master:~$ kubectl delete service -l app=wordpress
vagrant@master:~$ kubectl delete deployment -l app=wordpress
vagrant@master:~$ kubectl delete pvc -l app=wordpress

vagrant@master:~$ kubectl delete secret mysql-pass



